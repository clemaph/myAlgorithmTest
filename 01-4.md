### day20：分治算法
##### 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
> Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

> Input: preorder = [-1], inorder = [-1]
Output: [-1]

```javascript
/*递归*/
var buildTree = function(preorder, inorder) {
    if (preorder.length === 0 || inorder.length === 0) {
        return null
    }
    const index = inorder.findIndex(item => item === preorder[0])
    const left = inorder.slice(0, index)
    const right = inorder.slice(index + 1)
    return {
        val : preorder[0],
        left : buildTree(preorder.slice(1, index + 1), left),
        right : buildTree(preorder.slice(index + 1), right)
    }
};
```
##### 数值的整数次方
实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
> 输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25

> 输入：x = 2.10000, n = 3
输出：9.26100

```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */

//一刷战败 ：
/*
这测试用例再来一百个，好评
2.00000
-2147483648
 *//* 
var myPow = function(x, n) {
    let reusult = 1
    let pow = Math.abs(n)
    while(pow){
        reusult*=x
        pow--
        }
    if(n<0){
        reusult = 1/reusult
    }
    return reusult
};*/
//传统做法时间复杂度高，经不起测试，改用快速幂的思想
var myPow = function(x, n) {
    let reusult = 1.0
    //如果负数，2^-2可以编程 （1/2）^2
    if(n<0){
        //js中默认不是整除
        x = 1/x
        n = -n
    }
    while(n>0){
        if(n&1){
            reusult*=x
        }
        x*=x
        //我的天，js中的移位还出错
        //原来是>>是有符号数的移位，>>>这个是无符号数的移位
        //下面第一种是错误的，剩下两个都是正确的
        // n = n>>1
        // n = Math.floor(n/2)
        n = n>>>1
    }
    return reusult
};
```
##### 二叉搜索树的后序遍历序列
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
> 输入: [1,6,3,2,5]
输出: false

> 输入: [1,3,2,6,5]
输出: true

**递归分治**

根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性 （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。
```python
class Solution:
    def verifyPostorder(self, postorder: [int]) -> bool:
        def recur(i, j):
            if i >= j: return True
            p = i
            while postorder[p] < postorder[j]: p += 1
            m = p
            while postorder[p] > postorder[j]: p += 1
            return p == j and recur(i, m - 1) and recur(m, j - 1)
        return recur(0, len(postorder) - 1)
```
**辅助单调栈**
```python
class Solution:
    def verifyPostorder(self, postorder: [int]) -> bool:
        stack, root = [], float("+inf")
        for i in range(len(postorder) - 1, -1, -1):
            if postorder[i] > root: return False
            while(stack and postorder[i] < stack[-1]):
                root = stack.pop()
            stack.append(postorder[i])
        return True
```
### day21：位运算
##### 二进制中1的个数

##### 不用加减乘除做加法

### day22：位运算
##### 数组中数字出现的次数I

##### 数组中数字出现的次数II

### day23：数学
##### 数组中出现次数超过一半的数字

##### 构建乘积数组

### day24：数学
##### 剪绳子

##### 和为s的连续正数序列

##### 圆圈中最后剩下的数字

### day25：模拟
##### 顺时针打印矩阵

##### 栈的压入、弹出序列
