### day7：搜索与回溯算法
##### 树的子结构
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即A中有出现和B相同的结构和节点值。
> 输入：A = [1,2,3], B = [3,1]
输出：false

> 输入：A = [3,4,5,1,2], B = [4,1]
输出：true

**DFS深度优先**

```javascript
var isSubStructure = function(A, B) {
    if(!B||!A) return false;
    const dfs=(A,B)=>{
        if(!B) return true;
        if(!A) return false;
        return A.val===B.val&&dfs(A.left,B.left)&&dfs(A.right,B.right);
    }
    return dfs(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B);
};
```

##### 二叉树的镜像
请完成一个函数，输入一个二叉树，该函数输出它的镜像。\
> 输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

**递归法**

从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转得到镜像。如果当前遍历到的节点 root 的左右两棵子树都已经翻转得到镜像，那么我们只需要交换两棵子树的位置，即可得到以 root 为根节点的整棵子树的镜像。
```javascript
var mirrorTree = function(root) {
    if (root === null) {
        return null;
    }
    const left = mirrorTree(root.left);
    const right = mirrorTree(root.right);
    root.left = right;
    root.right = left;
    return root;
};
```
**复杂度分析**
- 时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。
- 空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。

##### 对称的二叉树
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的。
> 输入：root = [1,2,2,3,4,4,3]
输出：true

> 输入：root = [1,2,2,null,3,null,3]
输出：false

**DFS深度优先**

```javascript
var isSymmetric = function(root) {
    if(!root) return null;
    const dfs=(rLeft,rRight)=>{
        if(!rLeft&&!rRight) return true;
        if(!rLeft||!rRight) return false;
        return rLeft.val===rRight.val&&dfs(rLeft.right,rRight.left)&&dfs(rLeft.left,rRight.right);
    }
    return dfs(root.left,root.right);
};
```

### day8：动态规划
##### 斐波那契数列

##### 青蛙跳台阶

##### 股票的最大利润

### day9：动态规划
##### 连续子数组的最大和

##### 礼物的最大价值

### day10：动态规划
##### 把数字翻译成字符串

##### 最长不含重复字符的子字符串

### day11：双指针
##### 删除链表的节点

##### 链表的倒数第k个节点

### day12：双指针
##### 合并两个排序的链表

##### 两个链表的第一个公共节点

### day13：双指针
##### 调整数组顺序使奇数位于偶数前面

##### 和为s的两个数字

##### 翻转单词顺序I
