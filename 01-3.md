### day14：搜索与回溯算法
##### 矩阵中的路径
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

> 输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false

**DFS+剪枝**
```javascript
var exist = function(board, word) {
    //1.遍历整个board,找到word字符串第一个单词匹配的单词
    //2.找到单词后，我们将调用search函数遍历每种可能的组合（上，下，左，右）
    //3.如果该函数返回true，则 字符串存在
    //4.否者继续检查，直到退出循环为止。
    for(let c = 0 ,cLen=board.length; c<cLen;c++){
        for(let r = 0,rLen=board[c].length; r<rLen;r++){
            if(board[c][r] === word[0]){
                if(search(board,word,c,r)){
                    return true
                }
            }
        }
    }
    function search(b,w,c,r){
        //过滤情况
        //如果字符串为空，我们已经找到它。
        if(w==="") return true;
        //边界拦截
        if(!(c>=0)|| !(c<b.length) ||!(r>=0) || !(r<b[c].length))  return false
        //再次检查第一个字母是否相同
        if(b[c][r] != w[0]) return false
        //我们需要把已遍历过的打上标记 “#”，
        //但考虑到其他遍历需要这个变量，用个变量存储它
        //我们将变量放到底部的递归调用之后的那个位置，以便其他递归调用拥有它
        let temp = b[c][r];
        b[c][r] = "#"
        //只要有一种可能成立就return true
        if(
        //下一列
        search(b,w.slice(1),c+1,r)||
        //上一列
        search(b,w.slice(1),c-1,r)||
        //向左
        search(b,w.slice(1),c,r+1)||
        //向右
        search(b,w.slice(1),c,r-1)
        ){
            b[c][r] = temp;
            return true
        }else{
            //还原
            b[c][r] = temp;
            return false
        }
    }
    return false;
};
```

##### 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
> 输入：m = 2, n = 3, k = 1
输出：3

> 输入：m = 3, n = 1, k = 0
输出：1

```javascript
/*DFS*/
var movingCount = function(m, n, k) {
    const dir = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    function numDFS(i, j, isVisited) {
        const key = i + '-' + j;
        if (i < 0 || i >= m || j < 0 || j >= n || isVisited[key]) return 0;
        if (('' + i + j).split('').reduce((t, i) => t + +i, 0) > k) return 0;
        isVisited[key] = true;
        return dir.reduce((t, [offsetX, offsetY]) => t + numDFS(i + offsetX, j + offsetY, isVisited), 0) + 1;
    }
    return numDFS(0, 0, {});
};
/*BFS*/
var movingCount = function(m, n, k) {
    const queue = [[0, 0]];
    let res = 0, i = 1;
    const isVisited = {};
    while(i) {
        while(i--) {
            const [i, j] = queue.shift();
            const key = i + '-' + j;
            if (i >= m || j >= n || isVisited[key] || ('' + i + j).split('').reduce((t, i) => t + +i, 0) > k) continue;
            res++;
            isVisited[key] = true;
            queue.push([i + 1, j], [i, j + 1])
        }
        i = queue.length;
    }
    return res;
};
```

### day15：搜索与回溯算法
##### 二叉树中和为某一值的路径
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

> 输入：root = [1,2], targetSum = 0
输出：[]

```javascript
var pathSum = function(root, target) {
    let res=[];
    if(!root) return res;
    const pathRecord=(node,sum,path)=>{
        path.push(node.val);
        if(!node.left&&!node.right&&node.val===sum) res.push(path)
        /* slice()浅拷贝 */
        if(node.left) pathRecord(node.left,sum-node.val,path.slice())
        if(node.right) pathRecord(node.right,sum-node.val,path.slice())
    }
    pathRecord(root,target,[]);
    return res;
};
```

##### 二叉搜索树与双向链表
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
```javascript
var treeToDoublyList = function(root) {
    if(!root) return null;
    let head=null,pre=null
    const dfs=(root)=>{
        if(!root) return
        dfs(root.left)
        if(pre===null) head=root
        else{
            pre.right=root
            root.left=pre
        }
        pre=root
        dfs(root.right)
    }
    dfs(root)
    head.left=pre
    pre.right=head
    return head
};
```

##### 二叉搜索树的第k大节点
给定一棵二叉搜索树，请找出其中第 k 大的节点的值。
> 输入: root = [5,3,6,2,4,null,null,1], k = 3
输出: 4

二叉搜索树的一个特性：通过中序遍历所得到的序列，就是有序的。采用中序遍历，将二叉搜索树的节点值以升序放在数组中；然后采用数组的逆序方法，返回第k-1个数值。
```javascript
var kthLargest = function(root, k) {
    let res=[];
    const dfs=(node)=>{
        if(!node) return null;
        dfs(node.left);
        res.push(node.val); 
        dfs(node.right);
    }
    dfs(root)
    /*res.sort((a,b)=>b-a)*/
    /*console.log(res)*/
    /*return res[k-1]*/
    res.reverse()
    return res[--k]
};
```

### day16：排序
##### 把数组排成最小的数

##### 扑克牌中的顺子

### day17：排序
##### 最小的k个数

##### 数据流中的中位数

### day18：搜索与回溯算法
##### 二叉树的深度

##### 平衡二叉树

### day19：搜索与回溯算法
##### 求1+2+……+n

##### 二叉搜索树的最近公共祖先I

##### 二叉搜索树的最近公共祖先II
