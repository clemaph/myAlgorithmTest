### day14：搜索与回溯算法
##### 矩阵中的路径
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

> 输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false

**DFS+剪枝**
```javascript
var exist = function(board, word) {
    //1.遍历整个board,找到word字符串第一个单词匹配的单词
    //2.找到单词后，我们将调用search函数遍历每种可能的组合（上，下，左，右）
    //3.如果该函数返回true，则 字符串存在
    //4.否者继续检查，直到退出循环为止。
    for(let c = 0 ,cLen=board.length; c<cLen;c++){
        for(let r = 0,rLen=board[c].length; r<rLen;r++){
            if(board[c][r] === word[0]){
                if(search(board,word,c,r)){
                    return true
                }
            }
        }
    }
    function search(b,w,c,r){
        //过滤情况
        //如果字符串为空，我们已经找到它。
        if(w==="") return true;
        //边界拦截
        if(!(c>=0)|| !(c<b.length) ||!(r>=0) || !(r<b[c].length))  return false
        //再次检查第一个字母是否相同
        if(b[c][r] != w[0]) return false
        //我们需要把已遍历过的打上标记 “#”，
        //但考虑到其他遍历需要这个变量，用个变量存储它
        //我们将变量放到底部的递归调用之后的那个位置，以便其他递归调用拥有它
        let temp = b[c][r];
        b[c][r] = "#"
        //只要有一种可能成立就return true
        if(
        //下一列
        search(b,w.slice(1),c+1,r)||
        //上一列
        search(b,w.slice(1),c-1,r)||
        //向左
        search(b,w.slice(1),c,r+1)||
        //向右
        search(b,w.slice(1),c,r-1)
        ){
            b[c][r] = temp;
            return true
        }else{
            //还原
            b[c][r] = temp;
            return false
        }
    }
    return false;
};
```

##### 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
> 输入：m = 2, n = 3, k = 1
输出：3

> 输入：m = 3, n = 1, k = 0
输出：1

```javascript
/*DFS*/
var movingCount = function(m, n, k) {
    const dir = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    function numDFS(i, j, isVisited) {
        const key = i + '-' + j;
        if (i < 0 || i >= m || j < 0 || j >= n || isVisited[key]) return 0;
        if (('' + i + j).split('').reduce((t, i) => t + +i, 0) > k) return 0;
        isVisited[key] = true;
        return dir.reduce((t, [offsetX, offsetY]) => t + numDFS(i + offsetX, j + offsetY, isVisited), 0) + 1;
    }
    return numDFS(0, 0, {});
};
/*BFS*/
var movingCount = function(m, n, k) {
    const queue = [[0, 0]];
    let res = 0, i = 1;
    const isVisited = {};
    while(i) {
        while(i--) {
            const [i, j] = queue.shift();
            const key = i + '-' + j;
            if (i >= m || j >= n || isVisited[key] || ('' + i + j).split('').reduce((t, i) => t + +i, 0) > k) continue;
            res++;
            isVisited[key] = true;
            queue.push([i + 1, j], [i, j + 1])
        }
        i = queue.length;
    }
    return res;
};
```

### day15：搜索与回溯算法
##### 二叉树中和为某一值的路径

##### 二叉搜索树与双向链表

##### 二叉搜索树的第k大节点

### day16：排序
##### 把数组排成最小的数

##### 扑克牌中的顺子

### day17：排序
##### 最小的k个数

##### 数据流中的中位数

### day18：搜索与回溯算法
##### 二叉树的深度

##### 平衡二叉树

### day19：搜索与回溯算法
##### 求1+2+……+n

##### 二叉搜索树的最近公共祖先I

##### 二叉搜索树的最近公共祖先II
